;; MODIFIED FROM on http://modelingcommons.org/browse/one_model/3645#model_tabs_browse_info

turtles-own
[
  p-velocx                ;; x velocity
  p-velocy                ;; y velocity
  desired-direction ;; my desired direction
  driving-forcex    ;; my main motivating force
  driving-forcey
  obstacle-forcex   ;; force exerted by obstacles
  obstacle-forcey
  territorial-forcex;; force exerted by neighbors
  territorial-forcey
]

;;;; Functions for calculating the social forces ;;;;
to verify-arrival
  if patch-here = p-goal and patch-here != p-destination [ set p-goal first p-remain set p-remain but-first p-remain ]
  if patch-here = p-destination [ die ]
end

;; find the heading towards the nearest goal
to calc-desired-direction
  set desired-direction towards p-goal
;  if distance-to-agent p-goal < rd 5
;  [ let dist-to-goal distance-to-agent p-goal
;    let new-goal-x [pxcor] of p-goal + (1 / dist-to-goal) * sin (angle p-goal item 1 p-remain)
;    let new-goal-y [pycor] of p-goal + (1 / dist-to-goal) * cos (angle p-goal item 1 p-remain)
;;    show p-goal
;;    show new-goal-x
;;    show new-goal-y
;    set desired-direction towards patch-at new-goal-x new-goal-y ]
end

;to-report angle [ a b ]
;  let ang 0
;  ask b [ set ang towards a ]
;  report ang 
;end
;
;to-report distance-to-agent [ agent ]
;  report rd distance agent
;end
;
;to-report distance-to-point [ x y ]
;  report sqrt ( (xcor - x) ^ 2 + (ycor - y) ^ 2 )
;end



;to-report calc-partial-driving-force-x [ i-goal power ]
;  let dir towards i-goal
;  let gamma 0.9 ^ power
;  let partial-drive-force-x gamma * (1 / tau) * (p-veloc-max * (sin dir) - p-velocx) 
;  report partial-drive-force-x
;end
;
;to-report calc-partial-driving-force-y [ i-goal power ]
;  let dir towards i-goal
;  let gamma 0.9 ^ power
;  let partial-drive-force-y gamma * (1 / tau) * (p-veloc-max * (cos dir) - p-velocy)
;  report partial-drive-force-y
;end
;
;to-report partial-forcesx
;  let forcesx map [ x -> calc-partial-driving-force-x x position x p-remain ] p-remain
;  report sum forcesx
;end
;
;to-report partial-forcesy
;  let forcesy map [ y -> calc-partial-driving-force-y y position y p-remain ] p-remain
;  report sum forcesy
;end

;; find the driving force of the turtle
to calc-driving-force
  set driving-forcex (1 / tau) * (p-veloc-max * (sin desired-direction) - p-velocx); + partial-forcesx 
  set driving-forcey (1 / tau) * (p-veloc-max * (cos desired-direction) - p-velocy); + partial-forcesy
end

;; find the territorial force according to the social forces model
to calc-territorial-forces
  set territorial-forcex 0
  set territorial-forcey 0
  ask other turtles with [distance myself > 0]
  [
    let to-agent (towards myself) - 180
    let rabx [xcor] of myself - xcor
    let raby [ycor] of myself - ycor
    let speed magnitude p-velocx p-velocy
    let to-root ((magnitude rabx raby) + (magnitude (rabx - (speed * sin desired-direction)) (raby - (speed * cos desired-direction)))) ^ 2 - speed ^ 2
    if to-root < 0
    [set to-root 0]
    let b 0.5 * sqrt to-root

    let agent-force (- v0) * exp (- b / sigma)

    ask myself
    [
      let agent-forcex agent-force * (sin to-agent)
      let agent-forcey agent-force * (cos to-agent)
      ;; modify the effect this force has based on whether or not it is in the field of view
      let vision field-of-view-modifier driving-forcex driving-forcey agent-forcex agent-forcey
      set territorial-forcex territorial-forcex + agent-forcex * vision
      set territorial-forcey territorial-forcey + agent-forcey * vision
    ]
  ]
end

;; move the turtle according to the rules of the social forces model
to move-peds
  let ax driving-forcex + obstacle-forcex + territorial-forcex
  let ay driving-forcey + obstacle-forcey + territorial-forcey

  set p-velocx p-velocx + ax
  set p-velocy p-velocy + ay

  ;; scale down the velocity if it is too high
  let vmag magnitude p-velocx p-velocy
  let multiplier 1
  if vmag > p-veloc-max
  [set multiplier p-veloc-max / vmag]

  set p-velocx p-velocx * multiplier
  set p-velocy p-velocy * multiplier

  set xcor xcor + p-velocx
  set ycor ycor + p-velocy
  
  if p-velocx != 0
  [ set heading atan p-velocx p-velocy ]

end

;; find the obstacle force of the turtle according to the social forces model
to calc-obstacle-force
  set obstacle-forcex 0
  set obstacle-forcey 0
  ask patches in-radius (rd swidth) with [pcolor = 89]
  [
    let to-obstacle (towards myself) - 180
    let obstacle-force (- u0) * exp (- (distance myself) / r)
    ask myself
    [
     set obstacle-forcex obstacle-forcex + obstacle-force * (sin to-obstacle)
     set obstacle-forcey obstacle-forcey + obstacle-force * (cos to-obstacle)
    ]
  ]
  ask cars in-radius (rd 5)
  [
    let to-obstacle (towards myself) - 180
    let obstacle-force (- u0) * exp (- (distance myself) / r)
    ask myself
    [
     set obstacle-forcex obstacle-forcex + obstacle-force * (sin to-obstacle)
     set obstacle-forcey obstacle-forcey + obstacle-force * (cos to-obstacle)
    ]
  ]
end


;; helper function to find the magnitude of a vector
to-report magnitude [x y]
  report sqrt ((x ^ 2) + (y ^ 2))
end

;; returns 1 if the angle between the desired vector and the force vector is within a threshold, else return c
to-report field-of-view-modifier [desiredx desiredy forcex forcey]
  ifelse (desiredx * (- forcex) + desiredy * (- forcey)) >= (magnitude forcex forcey) * cos (60 / 2)
  [ report 1 ]
  [ report 0.5]
end





